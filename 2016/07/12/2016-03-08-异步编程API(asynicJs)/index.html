<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Engineer | Listen</title>
  <meta name="description" content="{{theme.description}}" />
  <meta name="keywords" content="{{theme.keywords}}" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="流程控制
series(tasks,[callback])
串行执行，一个函数数组中的每个函数，每一个函数执行完成之后才能执行下一个函数。回调函数最终会接受一个数组，为每个函数的结果的集合。
如果在数组中函数执行的过程中某个函数出错，会传递错误到回调函数callback中，并且终结整个series函数的执行，回调函数会给error赋予err的值。
也可以使用对象代替参数里面tasks，那么ser">
<meta property="og:type" content="article">
<meta property="og:title" content="Engineer | Listen">
<meta property="og:url" content="http://yoursite.com/2016/07/12/2016-03-08-异步编程API(asynicJs)/index.html">
<meta property="og:site_name" content="Engineer | Listen">
<meta property="og:description" content="流程控制
series(tasks,[callback])
串行执行，一个函数数组中的每个函数，每一个函数执行完成之后才能执行下一个函数。回调函数最终会接受一个数组，为每个函数的结果的集合。
如果在数组中函数执行的过程中某个函数出错，会传递错误到回调函数callback中，并且终结整个series函数的执行，回调函数会给error赋予err的值。
也可以使用对象代替参数里面tasks，那么ser">
<meta property="og:image" content="http://7xro5v.com1.z0.glb.clouddn.com/asyncjs.png">
<meta property="og:updated_time" content="2016-07-12T02:55:44.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Engineer | Listen">
<meta name="twitter:description" content="流程控制
series(tasks,[callback])
串行执行，一个函数数组中的每个函数，每一个函数执行完成之后才能执行下一个函数。回调函数最终会接受一个数组，为每个函数的结果的集合。
如果在数组中函数执行的过程中某个函数出错，会传递错误到回调函数callback中，并且终结整个series函数的执行，回调函数会给error赋予err的值。
也可以使用对象代替参数里面tasks，那么ser">
<meta name="twitter:image" content="http://7xro5v.com1.z0.glb.clouddn.com/asyncjs.png">
  
  
    <link rel="icon" href="/favicon.png">
  
  
	<script src="https://use.typekit.net/eyf3hir.js"></script>
  <script>try{Typekit.load({ async: false });}catch(e){}</script>
  <link rel="stylesheet" href="/style.css">
  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
</head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>

  <script>setLoadingBarProgress(20)</script>
  
  <div id="site-wrapper">
    
    <header id="header">
	<div id="header-wrapper" class="clearfix">
		<a id="logo" href="/">
			<img src="/images/logo.png" />
			<span id="site-desc">
			  otaku keeps alive
      </span>
		</a>
		<button id="site-nav-switch">
	    <span class="icon icon-menu"></span>
	  </button>
	</div>
	<aside id="site-menu">
  	<nav>
  		
        <a href="/" class="nav-home nav">
          Home
        </a>
      
        <a href="/about" class="nav-about nav">
          About
        </a>
      
        <a href="/archives" class="nav-archives nav">
          Archives
        </a>
      
    </nav>
	</aside>
</header>
    <script>setLoadingBarProgress(40);</script>
    
    <main id="main" role="main">
      <article id="post-2016-03-08-异步编程API(asynicJs)"
  class="post article white-box article-type-post"
  itemscope itemprop="blogPost">
	<h2 class="title">
  	<a href="/2016/07/12/2016-03-08-异步编程API(asynicJs)/">
    	
    </a>
  </h2>
	<time>
	  7月 12, 2016
	</time>
	<section class="content">
  	<div class="article-entry" itemprop="articleBody">
    	<p><img src="http://7xro5v.com1.z0.glb.clouddn.com/asyncjs.png" alt="async"></p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><ol>
<li><p>series(tasks,[callback])</p>
<p>串行执行，一个函数数组中的每个函数，每一个函数执行完成之后才能执行下一个函数。回调函数最终会接受一个数组，为每个函数的结果的集合。</p>
<p>如果在数组中函数执行的过程中某个函数出错，会传递错误到回调函数callback中，并且终结整个series函数的执行，回调函数会给error赋予err的值。</p>
<p>也可以使用对象代替参数里面tasks，那么series会将对象里的每个属性当作函数一样去运行，最终传递到回调函数中的不是一个数组而是一个对象。</p>
<p>tasks:一个数组或者对象包含多个函数，每个函数包含一个回调函数，回<br>调函数有参数：err(可以为空)和一个value</p>
<p>callback：可选参数，这个函数的参数有err(可以为空)，和一个tasks函数组运行后返回的结果集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">async.series(&#123;</div><div class="line">  one:function(callback)&#123;</div><div class="line">    setTimeout(function()&#123;</div><div class="line">      callback(null,1);</div><div class="line">    &#125;,200)</div><div class="line">  &#125;,</div><div class="line">  two:function(callback)&#123;</div><div class="line">    setTimeout(function()&#123;</div><div class="line">      callback(null,2);</div><div class="line">    &#125;,100);</div><div class="line">  &#125;</div><div class="line">&#125;,function(err,result)&#123;</div><div class="line">  //result &#123;one:1,two:2&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>parallel(tasks,[callback])</p>
<p>并行执行，运行tasks中的的函数组，并且不需要等待前一个函数运行完毕之后就可以立即执行下一个函数。</p>
<p>如果函数组中有任一个函数的回调函数中err有值，会立即停parallel的运行，并且在最终的callback中会接收这个err的值。</p>
<p>函数组运行完成之后，回调函数会接受一个返回值的集合。</p>
<p>注意事项： 如果函数的执行过程中没有I/O或者延时执行，那么实际上函数组的执行也是串行执行。</p>
<p>parallel也可以接受一个对象作为函数组tasks</p>
<p>tasks：一个函数数组或者一个对象，每个函数都有一个回调函数，回调函数必须有一个err参数(可以为空)和一个数组包括返回值的数组</p>
<p>callback：所有函数运行完毕后执行的函数，这个函数接收err参数和一个返回值的结果集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">async.parallel(&#123;</div><div class="line"> one: function(callback)&#123;</div><div class="line">     setTimeout(function()&#123;</div><div class="line">         console.log(1);</div><div class="line">         callback(null, 1);</div><div class="line">     &#125;, 200);</div><div class="line"> &#125;,</div><div class="line"> two: function(callback)&#123;</div><div class="line">     setTimeout(function()&#123;</div><div class="line">         console.log(2);</div><div class="line">         callback(null, 2);</div><div class="line">     &#125;, 100);</div><div class="line"> &#125;</div><div class="line">&#125;,</div><div class="line">function(err, results) &#123;</div><div class="line">  console.log(results)</div><div class="line">&#125;);</div><div class="line">//2</div><div class="line">//1</div><div class="line">//&#123;one:1,two:2&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>whilst(test,fn(callback),callback)</p>
<p>反复执行fn,直到test的值为true。<br>当函数执行停止了或者抛出了错误时就会调用回调函数，接收err或者最终的返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">async.whilst(</div><div class="line">  function()&#123;return count&#125;,</div><div class="line">  function(callback)&#123;</div><div class="line">    count ++</div><div class="line">    setTimeout(function()&#123;</div><div class="line">      callback(null,count);</div><div class="line">    &#125;,1000);</div><div class="line">  &#125;,</div><div class="line">  function(err,n)&#123;</div><div class="line">    console.log(n);</div><div class="line">  &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
</li>
<li><p>doWhilst(fn,test,callback)</p>
<p>与whilst的关系类似于 while 和 do..while</p>
<p>先执行一次的区别</p>
</li>
<li><p>until(test,fn,callback)</p>
<p>同whilst(test,fn,callback) 但是判断条件是逆序的</p>
</li>
<li><p>doUntil(fn,test,callback)</p>
<p>同doWhilst(fn,test,callback) 但是判断条件是逆序的</p>
</li>
<li><p>during(test,fn,callback)</p>
<p>和whilst类似，但是test是通过传递形如function(err,truth)的一个异步函数来返回判断结果。但错误发生在test或者fn的时候，会立即停止运行，然后最终的回调函数会接收到错误对象。</p>
</li>
<li><p>doDuring</p>
<p>不想解释了。</p>
</li>
<li><p>forever(fn,callback)</p>
<p>允许fn的函数体内自己在调用自己。</p>
<p>不论条件的执行fn，除非发生错误，否则永远都不会停止调用最终的回调函数。</p>
</li>
<li><p>waterfall(tasks,[callback])</p>
<p>串行执行，运行函数组中的函数，将上一个函数的运行结果传递给下一个函数。如果有错误发生，立即停止，callback接收错误。</p>
<p>tasks中的函数必须有一个回调函数cb，输入参数err(可以为空)和任意多个参数，让下一个函数接收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">async.waterfall([</div><div class="line">  function(cb)&#123;</div><div class="line">    cb(null,1,2);</div><div class="line">  &#125;,</div><div class="line">  function(arg1,arg2,cb)&#123;</div><div class="line">    cb(null,1);</div><div class="line">  &#125;</div><div class="line">],function(err,result)&#123;</div><div class="line">    console.log(result);</div><div class="line">&#125;);</div><div class="line">//1</div></pre></td></tr></table></figure>
<p>如果函数组中的第一个函数也需要传值，那么如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    async.waterfall([</div><div class="line">      async.apply(firstFunction,&apos;zero&apos;),</div><div class="line">      secondFunction,</div><div class="line">      lastFunction</div><div class="line">    ],function(err,result)&#123;</div><div class="line">      //...</div><div class="line">    &#125;)</div><div class="line">    ``` </div><div class="line">11. compose(fn1,fn2...)</div><div class="line"></div><div class="line">    创建一组异步函数的集合，每个函数都会将上一个函数的返回值作为参数执行。将f()、g()和h()组合成类似f(g(h()))的嵌套形式。</div></pre></td></tr></table></figure>
<p>function add1(n,callback){<br>  setTimeout(function(){</p>
<pre><code>callback(null,n+1);
</code></pre><p>  },10)<br>}<br>function add2(n,callback){<br>  setTimeout(function(){</p>
<pre><code>callback(null,n*3);
</code></pre><p>  })<br>}<br>var addmul = async.compose(add2,add1);<br>addmul(4,function(err,result){<br>  console.log(result);<br>  //15<br>})</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">    </div><div class="line">12. applyEach(fns,args...,callback)</div><div class="line"></div><div class="line">    向函数组中的每个函数都提供同样的参数，如果只设置第一个参数fns，则返回一个函数对象，我们可以传递参数以调用。</div></pre></td></tr></table></figure>
<p>async.applyEach([<br>  function(name,cb){</p>
<pre><code>setTimeout(function(){
  console.log(name,&apos;a&apos;);
  cb(null,name);
},500)
</code></pre><p>  },<br>  function(name,cb){</p>
<pre><code>setTimeout(function(){
  console.log(name,&apos;b&apos;);
  cb(null,name);
},100)
</code></pre><p>  }<br>],’hello’,function(err){<br>  console.log(‘err’,err);<br>})<br>//hello b<br>//hello a<br>//err null</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    applyEachSeries与之唯一不同之处是它是同步执行</div><div class="line">    </div><div class="line">13. queue(worker,[concurrency])</div><div class="line"></div><div class="line">    queue是一个串行的消息队列，通过限制了worker数量，不再一次性全部执行。当worker数量不够用时，新加入的任务将会排队等候，直到有新的worker可用。</div></pre></td></tr></table></figure>
<p>var q = async.queue(function(task, callback) {<br>  log(‘worker is processing task: ‘, task.name);<br>  task.run(callback);<br>}, 2);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">    </div><div class="line">    返回的q对象有如下方法和属性：</div><div class="line">    </div><div class="line">    length()：返回队列中处于等待状态的的函数的个数长度</div><div class="line">    </div><div class="line">    started()：返回队列中是否有任何函数</div><div class="line">    </div><div class="line">    running()：返回正在处理的函数的数目</div><div class="line">    </div><div class="line">    workersList()：返回正在处理的函数的队列</div><div class="line">    </div><div class="line">    idle()：返回boolean型值，如果有函数正在处理或者等待则返回false，否则返回true</div><div class="line">    </div><div class="line">    saturated：如果队列中的函数已经饱和，则执行该函数</div><div class="line">    </div><div class="line">    empty：如果队列中函数最后一个交给worker时，则执行该函数</div><div class="line">    </div><div class="line">    drain：当所有任务都执行完毕了，执行该函数</div><div class="line">    </div><div class="line">    push：向队列中加入一个或多个任务</div><div class="line">    </div><div class="line">    unshift(task,callback)：添加一个新的任务到队列的顶部</div><div class="line">    </div><div class="line">    concurrency：返回一个number型，记录有多少函数可以同时在队列中并行执行。</div><div class="line">    </div><div class="line">    paused：判断队列是否存于暂停状态，返回一个boolean型</div><div class="line">    </div><div class="line">    pause()：停止队列中的任务执行，知道resume()方法调用</div><div class="line">    </div><div class="line">    resume()：继续一个处于暂停状态的队列中的执行函数</div><div class="line">    </div><div class="line">    kill()：清空队列</div><div class="line">    </div><div class="line">14. priorityQueue(worker,concurrency)</div><div class="line">    </div><div class="line">    和queue()类似，但是有优先级，并且按照优先级的顺序执行函数</div><div class="line">    </div><div class="line">    和queue()的不同点，push(task,priority,[callback]) 增加执行的任务的时候多传一个参数代表优先级priority，没有unshift方法</div><div class="line">    </div><div class="line">    cargo(worker,[payload])</div><div class="line">    </div><div class="line">    和queue()类似，但是不是以一个个函数为单位进行添加和执行。而是以一组函数为一个单位，只有当一组函数全部执行完，才可以添加另一组函数开始执行。</div><div class="line">    </div><div class="line">    worker(tasks,callback) 一个用来执行队列中的函数组的回调函数，每个函数执行结束时必须调用它自身的回调函数，传递一个参数err</div><div class="line">    </div><div class="line">    payload：一项参数限制每轮执行函数组时，最多允许函数组中有多少个函数，如果payload没有传值，则认为无限制。</div></pre></td></tr></table></figure>
<p>var cargo = async.cargo(function (tasks, callback) {</p>
<pre><code>for(var i=0; i&lt;tasks.length; i++){
  console.log(&apos;hello &apos; + tasks[i].name);
}
callback();
</code></pre><p>}, 2);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">    length()：一个函数用来返回还有多少个函数等待执行</div><div class="line">    </div><div class="line">    payload：返回一个整型，有多少函数在每轮执行函数组时允许的函数个数</div><div class="line">    </div><div class="line">    push(task,[callback])：允许添加一个函数组</div><div class="line">    </div><div class="line">    saturated：当队列中函数组的个数达到payload限制时触发的函数</div><div class="line">    </div><div class="line">    empty：当队列中最后一个函数开始执行时调用</div><div class="line">    </div><div class="line">    drain：当队列中最后一个函数返回时调用</div><div class="line">    </div><div class="line">    idle()、pause()、resume()、kill() 继承这些函数和queue有相同的功能</div><div class="line">    </div><div class="line">15. auto(tasks,[callback])</div><div class="line"></div><div class="line">    用来执行依赖关系非常复杂的逻辑，列如存在部分任务可以并行执行，部分任务依赖某些任务执行完成之后才可以执行。</div></pre></td></tr></table></figure>
<p>async.auto({</p>
<pre><code>getData: function (callback) {
    setTimeout(function(){
        console.log(&apos;1.1: got data&apos;);
         callback(null, &apos;mydata&apos;);
    }, 300);
},
makeFolder: function (callback) {
    setTimeout(function(){
        console.log(&apos;1.1: made folder&apos;);
        callback(null, &apos;myfolder&apos;);
    }, 200);
},
writeFile: [&apos;getData&apos;, &apos;makeFolder&apos;, function(callback) {
    setTimeout(function(){
        console.log(&apos;1.1: wrote file&apos;);
        callback(null, &apos;myfile&apos;);
    }, 300);
}],
emailFiles: [&apos;writeFile&apos;, function(callback, results) {
    log(&apos;1.1: emailed file: &apos;, results.writeFile);
    callback(null, results.writeFile);
}]
</code></pre><p>}, function(err, results) {</p>
<pre><code>log(&apos;1.1: err: &apos;, err);
log(&apos;1.1: results: &apos;, results);
</code></pre><p>});</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">    </div><div class="line">    在demo中，1、2是并行执行的，但是3需要依赖1、2执行完成后串行执行，4需要依赖3完成。</div><div class="line">    </div><div class="line">16. iterator(tasks)</div><div class="line"></div><div class="line">    Generator函数的语法糖</div><div class="line">    第一次调用执行第一个函数，并返回一个遍历器对象，通过next()调用，执行第二个函数，以此类推，指导函数全部执行完成。</div></pre></td></tr></table></figure>
<p>var iter = async.iterator([</p>
<pre><code>function () {log(&apos;I am 111&apos;)},
function () {log(&apos;I am 222&apos;)},
function () {log(&apos;I am 333&apos;)}
</code></pre><p>]);<br>log(‘1.1 iter()’);<br>var it1 = iter();<br>it1();<br>it1();<br>//28.368&gt; 1.1 iter()<br>//28.371&gt; I am 111<br>//28.372&gt; I am 222<br>//28.372&gt; I am 222<br>```   </p>
</li>
</ol>

  	</div>
	  
	  <div class="article-tags tags">
		  
	  </div>
	</section>
</article>



      <script>setLoadingBarProgress(60);</script>
    </main>
    
    <footer id="footer" class="clearfix">
  
  
	<div class="search">
	  <form name="searchform" id="searchform" class="u-search-form">
	    <input type="text" id="searchinput" class="u-search-input" placeholder="Looking for something?" />
	    <button type="submit" id="u-search-btn-submit" class="u-search-btn-submit">
	      <span class="icon icon-search"></span>
	    </button>
	  </form>
	</div>
	

	<div class="social-wrapper">
  	
      
        <a href="https://github.com/artchen" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="https://twitter.com/otakism" class="social twitter"
          target="_blank" rel="external">
          <span class="icon icon-twitter"></span>
        </a>
      
        <a href="/atom.xml" class="social rss"
          target="_blank" rel="external">
          <span class="icon icon-rss"></span>
        </a>
      
        <a href="https://plus.google.com/+ArtChenOtakism/posts" class="social google"
          target="_blank" rel="external">
          <span class="icon icon-google"></span>
        </a>
      
        <a href="http://weibo.com/otakism/" class="social sina-weibo"
          target="_blank" rel="external">
          <span class="icon icon-sina-weibo"></span>
        </a>
      
    
  </div>
  
  <div>Theme <span class="codename">Typescript</span> designed by <a href="http://rakugaki.me/" target="_blank">Art Chen</a>.</div>
  <div>&copy; <a href="/">Engineer | Listen</a></div>
  
</footer>


    <script>setLoadingBarProgress(80);</script>
    
  </div>

  
  

<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script>window.jQuery || document.write('<script src="/js/jquery.min.js"><\/script>')</script>

<script src="/js/jquery.fitvids.js"></script>
<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "google";
</script>
<script src="/js/search.js"></script>
<script src="/js/app.js"></script>


  <script>setLoadingBarProgress(100);</script>
  
</body>
</html>
